/**
 *  @file  : apds_proximity.c
 *	
 *  @brief : Proximity engine handling. See datasheet pag 11
 *
 *  @author: Francesco Varani
 *  @date  : 13 nov 2020
 */
#include "apds_proximity.h"
#include "apds9660.h"
#include "apds_flag.h"
#include "apds_register.h"

#include "stm32f4xx.h"

volatile static uint8_t _p_saturation;
volatile static t_proximity_error _p_error;

/*
 * The Proximity detection feature provides distance measurement
 * Detect/release events are interrupt driven, and occur whenever proximity result crosses
 * upper and/or lower threshold settings.
 */
/**
 * @brief
 */
void apds_start_proximity_engine(void)
{
	_p_saturation = RESET;
	_p_error = e_proximity_error_none;
	/*
	 * TODO check if in SLEEP or IDLE !
	 */

	/*
	Optically, the IR emission appears as a pulse train. The
	number of pulses is set by the PPULSE bits and the period
	of each pulse is adjustable using the PPLEN bits.
	*/
	apds_proximity_set_ppulse(0x00);

	/* set threshold */
	apds_proximity_set_proximity_low_threshold(0x10);		/* value to set ?*/
	apds_proximity_set_proximity_high_threshold(0xF0);

	/*
	The intensity of the IR emission is selectable using the LDRIVE
	control bits; corresponding to four, factory calibrated,
	current levels. If a higher intensity is required (E.g. longer
	detection distance or device placement beneath dark
	glass) then the LEDBOOST bit can be used to boost current
	up to an additional 300%.
	 */


	/*
	 * Start ENABLE REGISTER:
	 * - ENABLE_REGISTER_PON = 1
	 * - ENABLE_REGISTER_PEN = 1
	 * what about saturation interrupt ?
	 */
	apds_write_generic(e_register_ENABLE, ENABLE_REGISTER_PON | ENABLE_REGISTER_PEN);
}

/**
 * @brief
 * @param from_interrupt
 */
void apds_proximity_read_result(uint8_t from_interrupt)
{
	uint8_t can_read = ERROR;
	uint8_t	read_data;
	uint8_t byte_read;

	/* read STATUS REGISTER 0x93 and check if PVALID is set */
	byte_read = apds_read_generic(e_register_STATUS,&read_data);

	if (byte_read != 0)
	{
		if (from_interrupt == APDS_READ_FROM_INTERRUPT)
		{
			if ((read_data & STATUS_REGISTER_PVALID) == STATUS_REGISTER_PINT)	/* check if PINT is set - we have received an interrupt */
			{
				can_read = SUCCESS;
			}
		}
		else
		{
			can_read = SUCCESS;
		}


		if ( (can_read == SUCCESS)
			&&	(read_data & STATUS_REGISTER_PVALID) == STATUS_REGISTER_PVALID)	/* check if PVALID is set*/
		{
			/* read PDATA 0x95 */
			byte_read = apds_read_generic(e_register_PDATA,&read_data);

			if (byte_read != 0)
			{

			}
		}

		if ((read_data & STATUS_REGISTER_PVALID) == STATUS_REGISTER_PGSAT)	/* check if PGSATT is set - Proximity saturation */
		{
			_p_saturation = SET;
			_p_error = e_proximity_error_saturation;
		}
		else
		{
			_p_saturation = RESET;
			_p_error = e_proximity_error_none;
		}
	}
	else
	{
		_p_error = e_proximity_error_data_not_valid;
	}
}

/**
 * @note The Proximity Pulse Count Register sets Pulse Width Modified current during a Proximity Pulse. The proximity pulse
 * count register bits set the number of pulses to be output on the LDR pin. The Proximity Length register bits set the
 * amount of time the LDR pin is sinking current during a proximity pulse
 * reset value = 0x40
 * @param flag
 */
void apds_proximity_set_ppulse(uint8_t flag)
{
	apds_write_generic(e_register_PPULSE, flag);
}

/**
 *
 * @param flag
 */
void apds_proximity_set_control(uint8_t flag)
{
	uint8_t	read_data;
	uint8_t byte_read;

	byte_read = apds_read_generic(e_register_CONTROL,&read_data);

	if (byte_read > 0)
	{
		flag = (read_data & (~CONTROL_REGISTER_ONE_PGAIN)) & (flag & CONTROL_REGISTER_ONE_PGAIN); /* just set stuff related to proximity */
		apds_write_generic(e_register_CONTROL, flag);
	}
}

/**
 *
 * @param flag
 */
void apds_proximity_set_config2(uint8_t flag)
{
	uint8_t	read_data;
	uint8_t byte_read;

	byte_read = apds_read_generic(e_register_CONFIG2,&read_data);

	if (byte_read > 0)
	{
		flag = (read_data & (~CONFIG2_PROXIMITY_VALID_FLAG)) & (flag & CONFIG2_PROXIMITY_VALID_FLAG); /* just set stuff related to proximity */
		apds_write_generic(e_register_CONFIG2, flag);
	}

}

/**
 *
 * @param flag
 */
void apds_proximity_set_config3(uint8_t flag)
{
	apds_write_generic(e_register_CONFIG3, flag);
}

/**
 * @note The Proximity Interrupt Threshold Registers set the high and low trigger points for the comparison function which generates an interrupt. If PDATA, the value generated by proximity channel, crosses below the lower threshold specified, or
 * above the higher threshold, an interrupt may be signaled to the host processor. Interrupt generation is subject to the
 * value set in persistence (PERS).
 * @param flag
 */
void apds_proximity_set_proximity_low_threshold(uint8_t flag)
{
	apds_write_generic(e_register_PILT, flag);
}

/**
 * @note The Proximity Interrupt Threshold Registers set the high and low trigger points for the comparison function which generates an interrupt. If PDATA, the value generated by proximity channel, crosses below the lower threshold specified, or
 * above the higher threshold, an interrupt may be signaled to the host processor. Interrupt generation is subject to the
 * value set in persistence (PERS).
 * reset value = 0x00
 * @param flag
 */
void apds_proximity_set_proximity_high_threshold(uint8_t flag)
{
	apds_write_generic(e_register_PIHT, flag);
}

/**
 * @note In proximity mode, the UP and RIGHT photodiodes are connected forming a diode pair. The POFFSET_UR is an 8-bit value
 * used to scale an internal offset correction factor to compensate for crosstalk in the application. This value is encoded in
 * sign/magnitude format.
 * reset value = 0x00
 * @param flag
 */
void apds_proximity_set_proximity_offset_ur(uint8_t flag)
{
	apds_write_generic(e_register_POFFSET_UR, flag);
}

/**
 * @note In Proximity mode, the DOWN and LEFT photodiodes are connected forming a diode pair. The POFFSET_DL is an 8-bit
 * value used to scale an internal offset correction factor to compensate for crosstalk in the application. This value is
 * encoded in sign/magnitude format
 * @param flag
 */
void apds_proximity_set_proximity_offset_dl(uint8_t flag)
{
	apds_write_generic(e_register_POFFSET_DL, flag);
}
